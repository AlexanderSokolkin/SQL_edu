# Конспект по изучению SQL ([курс](https://stepik.org/course/63054/syllabus))

_________________

## Содержание:
- [Урок 1 - Отношение](#урок-1---отношение)
- [Урок 2 - Выборка данных](#урок-2---выборка-данных)
- [Урок 3 - Запросы, групповые операции](#урок-3---запросы-групповые-операции)
- [Урок 4 - Вложеннын запросы](#урок-4---вложеннын-запросы)
- [Урок 5 - Запросы корректировки данных](#урок-5---запросы-корректировки-данных)

_________________

## Урок 1 - Отношение

- [Основные принципы реляционных баз данных](#базовые-понятия)
- [Создание таблицы](#создание-таблицы)
- [Вставка записи в таблицу](#вставка-записи-в-таблицу)


### Базовые понятия

**Основные принципы реляционных баз данных**:
- все данные на концептуальном уровне представляются в виде объектов, заданных в виде строк и столбцов, называемых отношением, более распространенное название – таблица;
- в пересечение строки и столбца таблицы можно занести только одно значение;
- все операции выполняются над целыми отношениями и результатом этих операций является отношение.


![table1](/src/l1_table_employee.png "Таблица \"Сотрудник\"")

**Терминология реляционных баз данных** на примере таблицы **Сотрудник**:

- **отношение**  – это структура данных целиком, набор записей (в обычном понимании – таблица), в примере – это `Сотрудник`;
- **кортеж** – это каждая строка, содержащая данные (более распространенный термин – запись), например, `<001, Борин С.А, 234-01-23, программист>`, все кортежи в отношении должны быть различны;
- **мощность** – число кортежей в таблице (проще говоря, число записей), в данном случае 3, мощность отношения может быть любой (от 0 до бесконечности), порядок следования кортежей - неважен;
- **атрибут** – это столбец в таблице (более распространенный термин – поле), в примере – `Табельный номер`, `Фамилия И.О.`, `Телефон`, `Должность` 
- **размерность** – это число атрибутов в таблице, в данном случае – 4;
- размерность отношения должна быть больше 0, порядок следования атрибутов существенен;
- **домен атрибута** – это допустимые значения (неповторяющиеся), которые можно занести в поле, например для атрибута `Должность` домен – {инженер, программист}.


> **Правила по выбору имени таблицы**:
> - может включать латинские буквы, цифры и знак подчеркивания, должно начинаться с буквы;
> - имя должно быть уникальным в пределах базы данных.
>
> **Рекомендации**:
> - чтобы имя было существительным в единственном числе;
> - имя должно быть понятным и соответствовать тому объекту, который оно описывает;
> - имя должно быть как можно короче, максимум до 10 символов.


> **Правила по выбору имени поля**:
> - может включать латинские буквы, цифры и знак подчеркивания, должно начинаться с буквы;
> - имя поля должно быть уникальным в пределах таблицы.
>
> **Рекомендации**:
> - имя должно быть понятным и соответствовать тем данным, которые хранятся в поле;
> - имя может состоять из нескольких слов, тогда слова разделяются подчеркиванием, после подчеркивания слово пишется с маленькой буквы.

> **Рекомендации по именованию ключевых полей**:
> - имя должно состоять из двух частей: начинаться с названия таблицы, которой поле принадлежит, затем через подчеркивание необходимо указать `id` (например, `employee_id`).


### Создание таблицы
Для создания таблицы используется SQL-запрос. В нем указывается какая таблица создается, из каких атрибутов(полей) она состоит и какой тип данных имеет каждое поле, при необходимости указывается описание полей (ключевое поле и т.д.). Его структура:

- ключевые слова : `CREATE TABLE`
- имя создаваемой таблицы;
- открывающая круглая скобка «(»;
- название поля и его описание, которое включает тип поля и другие необязательные характеристики;
- запятая;
- название поля и его описание;
- ...
- закрывающая скобка «)».

*Запрос*:
```
CREATE TABLE book(
    book_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(50),
    author VARCHAR(30),
    price DECIMAL(8,2),
    amount INT
);
```

### Вставка записи в таблицу
Для занесения новой записи в таблицу используется SQL запрос, в котором указывается в какую таблицу, в какие поля заносить новые значения. Структура запроса:

- ключевые слова `INSERT INTO` (ключевое слово `INTO` можно пропустить);
- имя таблицы, в которую добавляется запись;
- открывающая круглая скобка «(»;
- список полей через запятую, в которые следует занести новые данные;
- закрывающая скобка «)»;
- ключевое слово `VALUES`;
- открывающая круглая скобка «(»;
- список значений через запятую, которые заносятся в соответствующие поля, при этом текстовые значения заключаются в кавычки, числовые значения записываются без кавычек, в качестве разделителя целой и дробной части используется точка;
- закрывающая скобка «)».

> Note: новые значения нельзя добавлять в поля, описанные как `PRIMARY KEY AUTO_INCREMENT`

*Запрос*:
```
INSERT INTO book (title, author, price, amount)
VALUES ('Мастер и Маргарита', 'Булгаков М.А.', 670.99, 3);
```

*Запрос*:
```
INSERT INTO book (title, author, price, amount)
VALUES ('Белая гвардия',     'Булгаков М.А.',    540.50, 5),
       ('Идиот',             'Достоевский Ф.М.', 460.00, 10),
       ('Братья Карамазовы', 'Достоевский Ф.М.', 799.01, 2);
```

_________________

## Урок 2 - Выборка данных

- [Выборка всех данных из таблицы](#выборка-всех-данных-из-таблицы)
- [Выборка отдельных столбцов](#выборка-отдельных-столбцов)
- [Присвоение новых имен столбцам при формировании выборки](#присвоение-новых-имен-столбцам-при-формировании-выборки)
- [Выборка данных с созданием вычисляемого столбца](#выборка-данных-с-созданием-вычисляемого-столбца)
- [Выборка данных, вычисляемые столбцы, математические функции](#выборка-данных-вычисляемые-столбцы-математические-функции)
- [Выборка данных, вычисляемые столбцы, логические функции](#выборка-данных-вычисляемые-столбцы-логические-функции)
- [Выборка данных по условию](#выборка-данных-по-условию)
- [Выборка данных, логические операции](#выборка-данных-логические-операции)
- [Выборка данных, операторы BETWEEN, IN](#выборка-данных-операторы-between-in)
- [Выборка данных с сортировкой](#выборка-данных-с-сортировкой)
- [Выборка данных, оператор LIKE](#выборка-данных-оператор-like)

### Выборка всех данных из таблицы

Для того чтобы отобрать все данные из таблицы используется SQL запрос следующей структуры: 
- ключевое слово `SELECT`; 
- символ «*»; 
- ключевое слово `FROM`; 
- имя таблицы.

*Запрос*:
```
SELECT * FROM book;
```

### Выборка отдельных столбцов

Для того чтобы отобрать данные из определенных столбцов таблицы используется SQL запрос следующей структуры: 
- ключевое слово `SELECT`; 
- список столбцов таблицы через запятую; 
- ключевое слово `FROM`; 
- имя таблицы.

*Запрос*:
```
SELECT title, amount FROM book;
```

### Присвоение новых имен столбцам при формировании выборки

Для того чтобы отобрать данные из определенных столбцов таблицы и одновременно задать столбцам новые названия в результате выборки используется SQL запрос следующей структуры:
- ключевое слово `SELECT`; 
- имя столбца;
- ключевое слово `AS`; 
- новое название столбца (можно русскими буквами), выводимое в результате запроса, но это должно быть одно слово, если название состоит из двух слов – соединяйте их подчеркиванием, например, `Количество_книг`; 
- запятая; 
- имя столбца; 
- ....
- ключевое слово `FROM`; 
- имя таблицы.

*Запрос*:
```
SELECT title AS Название, amount FROM book;
```

### Выборка данных с созданием вычисляемого столбца

С помощью SQL запросов можно осуществлять арифметические и логические вычисления по каждой строке таблицы над целым столбцом. Результатом будет новый столбец. Для него в списке полей после оператора `SELECT` указывается выражение и задается имя через оператор `AS`.

Выражение может включать имена столбцов, константы, знаки операций, встроенные функции.

Результатом является таблица, в которую включены все данные из указанных после `SELECT` столбцов, а также новый столбец, в каждой строке которого вычисляется заданное выражение.

*Запросы*:
```
SELECT title, author, price, amount, 
    price * amount AS total 
FROM book;

SELECT title, amount, 
    cast((amount * '1.65') AS DECIMAL(5,2)) AS pack
FROM book;
```

### Выборка данных, вычисляемые столбцы, математические функции

В SQL реализовано множество [математических функций](https://learn.microsoft.com/ru-ru/sql/t-sql/functions/mathematical-functions-transact-sql?view=sql-server-ver15 "Microsoft Learn") для работы с числовыми данными. В таблице приведены некоторые из них.

![Math functions](/src/l2_math_functions.png "Краткий список математических функций для Microsoft SQL Server")

*Запрос*:
```
SELECT title, author, amount,
    ROUND(price * 0.7, 2) AS new_price
FROM book;
```


### Выборка данных, вычисляемые столбцы, логические функции

В SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция `IF()`:

```
IF(логическое_выражение, выражение_1, выражение_2)
```

Функция вычисляет `логическое_выражение`, если оно истина – в поле заносится значение `выражения_1`, в противном случае –  значение `выражения_2`. Все три параметра `IF()` являются обязательными.

Допускается использование вложенных функций, вместо `выражения_1` и/или `выражения_2` может стоять новая функция `IF()`.

*Запрос*:
```
SELECT title, amount, price,
    ROUND(IF(amount < 4, price * 0.5, IF(amount < 11, price * 0.7, price * 0.9)), 2) AS sale,
    IF(amount < 4, 'скидка 50%', IF(amount < 11, 'скидка 30%', 'скидка 10%')) AS Ваша_скидка
FROM book;
```

### Выборка данных по условию

С помощью запросов можно включать в итоговую выборку не все строки исходной таблицы, а только те, которые отвечают некоторому условию. Для этого после указания таблицы, откуда выбираются данные, задается ключевое слово `WHERE` и логическое выражение, от результата которого зависит будет ли включена строка в выборку или нет. Если условие – истина, то строка(запись) включается в выборку, если ложь – нет.

Логическое выражение может включать операторы сравнения (равно «=», не равно «<>», больше «>», меньше «<», больше или равно«>=», меньше или равно «<=») и выражения, допустимые в SQL.


> В логическом выражении после `WHERE` нельзя использовать названия столбцов, присвоенные им с помощью `AS`, так как при выполнении запроса сначала вычисляется логическое выражение для каждой строки исходной таблицы, выбираются строки, для которых оно истинно. А только после этого формируется "шапка запроса" – столбцы, включаемые в запрос.

*Запрос*:
```
SELECT title, author, price * amount AS total
FROM book
WHERE price * amount > 4000;
```

### Выборка данных, логические операции

Логическое выражение после ключевого слова `WHERE` кроме операторов сравнения и выражений может включать **логические операции** (**И** «and», **ИЛИ** «or», **НЕ** «not») и круглые скобки, изменяющие приоритеты выполнения операций.

Приоритеты операций:

1. круглые скобки
2. умножение  (*),  деление (/)
3. сложение  (+), вычитание (-)
4. операторы сравнения (=, >, <, >=, <=, <>)
5. NOT
6. AND
7. OR

*Запрос*:
```
SELECT title, author, price, amount
FROM book
WHERE (price < 500 OR price > 600) AND (price * amount >= 5000);
```

### Выборка данных, операторы BETWEEN, IN

Логическое выражение после ключевого слова `WHERE` может включать операторы  `BETWEEN` и `IN`. Приоритет у этих операторов такой же как у операторов сравнения, то есть они выполняются раньше, чем `NOT`, `AND`, `OR`.

Оператор `BETWEEN` позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.

*Запрос*:
```
SELECT title, amount 
FROM book
WHERE amount BETWEEN 5 AND 14;

/*Эквивалентно запросу:*/
SELECT title, amount 
FROM book
WHERE amount >= 5 AND amount <=14;
```

*Запрос*:
```
SELECT title, price 
FROM book
WHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');

/*Эквивалентно запросу:*/
SELECT title, price 
FROM book
WHERE author = 'Булгаков М.А.' OR author = 'Достоевский Ф.М.';
```

### Выборка данных с сортировкой

При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. Для этого используются ключевые слова `ORDER BY`, после которых задаются имена столбцов. При этом строки сортируются по первому столбцу. Если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы. По умолчанию `ORDER BY` выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово `ASC` (по возрастанию) или `DESC` (по убыванию). 

Столбцы после ключевого слова `ORDER BY` можно задавать:

- названием столбца;
- номером столбца;
- именем столбца (указанным после `AS`).

*Запрос*:
```
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, Количество DESC;
```

### Выборка данных, оператор LIKE

Оператор `LIKE` используется для сравнения строк. В отличие от операторов отношения равно (=) и не равно (<>), `LIKE` позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. Шаблон может включать **обычные символы** и **символы-шаблоны**. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки.

![Like operands](/src/l2_like_operands.png "Символы-шаблоны для оператора LIKE")

*Запрос*:
```
SELECT title FROM book 
WHERE title LIKE "______%";
/* эквивалентные условия 
title LIKE "%______"
title LIKE "%______%"
*/
```

_________________


## Урок 3 - Запросы, групповые операции

- [Выбор уникальных элементов столбца](#выбор-уникальных-элементов-столбца)
- [Выборка данных, групповые функции SUM и COUNT](#выборка-данных-групповые-функции-sum-и-count)
- [Выборка данных, групповые функции MIN, MAX и AVG](#выборка-данных-групповые-функции-min-max-и-avg)
- [Выборка данных c вычислением, групповые функции](#выборка-данных-c-вычислением-групповые-функции)
- [Вычисления по таблице целиком](#вычисления-по-таблице-целиком)
- [Выборка данных по условию, групповые функции](#выборка-данных-по-условию-групповые-функции)
- [Выборка данных по условию, групповые функции, WHERE и HAVING](#выборка-данных-по-условию-групповые-функции-where-и-having)

### Выбор уникальных элементов столбца

Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово `DISTINCT`, которое размещается сразу после `SELECT`.

*Запрос*:
```
SELECT DISTINCT author
FROM book;
```

Другой способ – использование оператора `GROUP BY`, который группирует данные при выборке, имеющие одинаковые значения в некотором столбце. Столбец, по которому осуществляется группировка, указывается после `GROUP BY`.
С помощью `GROUP BY` можно выбрать уникальные элементы столбца, по которому осуществляется группировка. Результат будет точно такой же как при использовании `DISTINCT`.

*Запрос*:
```
SELECT author
FROM book
GROUP BY author;
```

### Выборка данных, групповые функции SUM и COUNT

При группировке над элементами столбца, входящими в группу можно выполнить различные действия, например, просуммировать их или найти количество элементов в группе.
Подробно рассмотрим, как осуществляется группировка данных по некоторому столбцу и вычисления над группой на следующем примере:

```
SELECT author,
       SUM(amount),
       COUNT(amount)
FROM book
GROUP BY author;
```

1\. В таблице `book` определяются строки, в которых в столбце `author` одинаковые значения:

![SUM and COUNT example p1](/src/l3_SUM_COUNT_EXAMPLE_p1.png "Выделение групп по автору")

Получили 3 различные группы:

- **группа I** объединяет две записи, у которых в столбце `author` значение Булгаков М.А.;
- **группа II** объединяет три записи, у которых в столбце `author` значение Достоевский Ф.М.;
- **группа III** объединяет одну запись, у которой в столбце `author` значение Есенин С.А.

2\. Вместо каждой группы в результирующий запрос включается одна запись. Запись как минимум включает значение столбца, по которому осуществляется группировка (в нашем случае это author):

![SUM and COUNT example p2](/src/l3_SUM_COUNT_EXAMPLE_p2.png "Выделение групп по автору")

3\. Дальше можно выполнить вычисления над элементами **КАЖДОЙ** группы в отдельности, например, посчитать общее количество экземпляров книг каждого автора. Для этого используется групповая функция `SUM()`, а в скобках указывается столбец, по которому нужно выполнить суммирование (в нашем случае `amount`):

![SUM and COUNT example p3](/src/l3_SUM_COUNT_EXAMPLE_p3.png "Выделение групп по автору")

4\. Также можно посчитать, сколько записей относится к группе. Для этого используется функция `COUNT()`, в скобках можно указать **ЛЮБОЙ** столбец из группы, если группа не содержит пустых значений:

![SUM and COUNT example p4](/src/l3_SUM_COUNT_EXAMPLE_p4.png "Выделение групп по автору")


> `COUNT(*)` — подсчитывает все записи, относящиеся к группе, в том числе и со значением `NULL`;
> `COUNT(имя_столбца)`— возвращает количество записей конкретного столбца (только `NOT NULL`), относящихся к группе;
> Если столбец указан в `SELECT`  БЕЗ применения групповой функции, то он обязательно должен быть указан и в `GROUP BY`. Иначе получим ошибку.


*Запрос*
```
SELECT author AS Автор,
       COUNT(DISTINCT title) AS Различных_книг, /*Подсчет количества уникальных книг одного автора*/
       SUM(amount) AS Количество_экземпляров
FROM book
GROUP BY author;
```

### Выборка данных, групповые функции MIN, MAX и AVG
 
К групповым функциям SQL относятся: `MIN()`, `MAX()` и `AVG()`, которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.

*Запрос*
```
SELECT author,
       MIN(price) AS Минимальная_цена,
       MAX(price) AS Максимальная_цена,
       AVG(price) AS Средняя_цена
FROM book
GROUP BY author;
```

### Выборка данных c вычислением, групповые функции

В качестве аргумента групповых функций SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.

*Запрос*
```
SELECT author,
       ROUND(SUM(price * amount),2) AS Стоимость,
       ROUND(SUM(price * amount) * 0.18 / 1.18, 2) AS НДС,
       ROUND(SUM(price * amount) / 1.18, 2) AS Стоимость_без_НДС
FROM book
GROUP BY author;
```

### Вычисления по таблице целиком

Групповые функции позволяют вычислять итоговые значения по всей таблице. Например, можно посчитать общее количество книг на складе, вычислить суммарную стоимость и пр. Для этого после ключевого слова `SELECT` указывается групповая функция для выражения или имени столбца, а ключевые слова `GROUP BY` опускаются. Результатом таких запросов является единственная строка с вычисленными по таблице значениями.

*Запрос*
```
SELECT SUM(amount) AS Количество, 
       SUM(price * amount) AS Стоимость
FROM book;
```

### Выборка данных по условию, групповые функции

В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после `WHERE`. В запросах с групповыми функциями вместо `WHERE` используется ключевое слово `HAVING`, которое размещается после оператора `GROUP BY`.

*Запрос*
```
SELECT author,
       MIN(price) AS Минимальная_цена, 
       MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000 
ORDER BY Минимальная_цена DESC;
```

### Выборка данных по условию, групповые функции, WHERE и HAVING

`WHERE` и `HAVING` могут использоваться в одном запросе. При этом необходимо учитывать порядок выполнения SQL запроса на выборку на СЕРВЕРЕ:

1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. SELECT
6. ORDER BY

Сначала определяется таблица, из которой выбираются данные (`FROM`), затем из этой таблицы отбираются записи в соответствии с условием `WHERE`, выбранные данные агрегируются (`GROUP BY`), из агрегированных записей выбираются те, которые удовлетворяют условию после `HAVING`. Потом формируются данные результирующей выборки, как это указано после `SELECT` (вычисляются выражения, присваиваются имена и пр.). Результирующая выборка сортируется, как указано после `ORDER BY`.

**Важно!** Порядок ВЫПОЛНЕНИЯ запросов - это не порядок ЗАПИСИ ключевых слов в запросе на выборку. Порядок ВЫПОЛНЕНИЯ нужен для того, чтобы понять, почему, например, в `WHERE` нельзя использовать имена выражений из `SELECT`. Просто `SELECT` выполняется компилятором позже, чем `WHERE`, поэтому ему неизвестно, какое там выражение написано.


> **MySQL**: `FROM` => `WHERE` = `SELECT` = `GROUP BY` = `HAVING` = `ORDER BY` = `LIMIT`.   
> **PostgreSQL**: `FROM` => `WHERE` = `GROUP BY` = `HAVING` = `SELECT` = `DISTINCT` = `ORDER BY` = `LIMIT`.

*Запрос*
```
SELECT author, SUM(price * amount) AS Стоимость
FROM book
WHERE title <> 'Идиот' AND title <> 'Белая гвардия'
GROUP BY author
HAVING SUM(price * amount) > 5000
ORDER BY Стоимость DESC;
```

_________________


## Урок 4 - Вложеннын запросы

- [Вложенный запрос, возвращающий одно значение](#вложенный-запрос-возвращающий-одно-значение)
- [Использование вложенного запроса в выражении](#использование-вложенного-запроса-в-выражении))
- [Вложенный запрос, оператор IN](#вложенный-запрос-оператор-in)
- [Вложенный запрос, операторы ANY и ALL](#вложенный-запрос-операторы-any-и-all)
- [Вложенный запрос после SELECT](#вложенный-запрос-после-select)


SQL позволяет создавать вложенные запросы. Вложенный запрос (подзапрос, внутренний запрос) – это запрос внутри другого запроса SQL. Вложенный запрос используется для выборки данных, которые будут использоваться в условии отбора записей основного запроса. Его применяют для:

- сравнения выражения с результатом вложенного запроса;
- определения того, включено ли выражение в результаты вложенного запроса;
- проверки того, выбирает ли запрос определенные строки.

Вложенный запрос имеет следующие компоненты:

- ключевое слово `SELECT`  после которого указываются имена столбцов или выражения (чаще всего список содержит один элемент);
- ключевое слово `FROM` и имя таблицы, из которой выбираются данные;
- необязательное предложение `WHERE`;
- необязательное предложение `GROUP BY`:
- необязательное предложение `HAVING`.

Вложенные запросы могут включаться в `WHERE` или `HAVING` так (в квадратных скобках указаны необязательные элементы, через | – один из элементов):

- `WHERE` | `HAVING` выражение оператор_сравнения (вложенный запрос);
- `WHERE` | `HAVING` выражение, включающее вложенный запрос;
- `WHERE` | `HAVING` выражение [`NOT`] `IN` (вложенный запрос);
- `WHERE` | `HAVING` выражение  оператор_сравнения  `ANY` | `ALL` (вложенный запрос).

Также вложенные запросы могут вставляться в основной запрос после ключевого слова `SELECT`.


### Вложенный запрос, возвращающий одно значение

Вложенный запрос, возвращающий одно значение, может использоваться в условии отбора записей `WHERE` как обычное значение совместно с операциями =, <>, >=, <=, >, <.

*Запрос*
```
SELECT title, author, price, amount
FROM book
WHERE price = (
         SELECT MIN(price) 
         FROM book
      );
```

### Использование вложенного запроса в выражении

Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, к нему можно что-то прибавить, вычесть и пр.

*Запрос*
```
SELECT title, author, amount 
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) > 3;
```

### Вложенный запрос, оператор IN

Вложенный запрос может возвращать несколько значений одного столбца. Тогда его можно использовать в разделе `WHERE` совместно с оператором `IN`.

`WHERE имя_столбца IN (вложенный запрос, возвращающий один столбец)`

Оператор `IN` определяет, совпадает ли значение столбца с одним из значений, содержащихся во вложенном запросе. При этом логическое выражение после `WHERE` получает значение истина. Оператор `NOT IN` выполняет обратное действие – выражение истинно, если значение столбца не содержится во вложенном запросе.

*Запрос*
```
SELECT title, author, amount, price
FROM book
WHERE author IN (
        SELECT author 
        FROM book 
        GROUP BY author 
        HAVING SUM(amount) >= 12
      );
```

### Вложенный запрос, операторы ANY и ALL

Вложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора записей с помощью операторов `ANY` и `ALL` совместно с операциями отношения (=, <>, <=, >=, <, >).

Операторы `ANY` и `ALL` используются в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.

При использовании оператора `ANY` в результирующую таблицу будут включены все записи, для которых выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. Как работает оператор `ANY`:

- `amount > ANY (10, 12)` эквивалентно `amount > 10`
- `amount < ANY (10, 12)` эквивалентно `amount < 12`
- `amount = ANY (10, 12)` эквивалентно `(amount = 10) OR (amount = 12)`, а также `amount IN (10, 12)`
- `amount <> ANY (10, 12)` вернет все записи с любым значением amount, так как эквивалентно `(amount <> 10) OR (amount <> 12)`

При использовании оператора `ALL` в результирующую таблицу будут включены все записи, для которых выражение со знаком отношения верно для всех элементов результирующего запроса. Как работает оператор `ALL`:

- `amount > ALL (10, 12)` эквивалентно `amount > 12`
- `amount < ALL (10, 12)` эквивалентно `amount < 10`
- `amount = ALL (10, 12)` не вернет ни одной записи, так как эквивалентно `(amount = 10) AND (amount = 12)`
- `amount <> ALL (10, 12)` вернет все записи кроме тех, в которых amount равно 10 или 12

**Важно!** Операторы `ALL` и `ANY` можно использовать только с вложенными запросами. В примерах выше (10, 12) приводится как результат вложенного запроса просто для того, чтобы показать как эти операторы работают. В запросах так записывать нельзя.

*Запрос*
```
SELECT title, author, amount, price
FROM book
WHERE amount < ANY (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );
```

### Вложенный запрос после SELECT

Вложенный запрос может располагаться после ключевого слова `SELECT`. В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы. При этом результатом запроса может быть только одно значение, тогда оно будет повторяться во всех строках. Также вложенный запрос может использоваться в выражениях.

*Запрос*
```
SELECT title, author, amount,
    ((SELECT MAX(amount) FROM book) - amount) AS Заказ
FROM book
WHERE amount <> (SELECT MAX(amount) FROM book)
```

_________________


## Урок 5 - Запросы корректировки данных

- [Добавление записей из другой таблицы](#добавление-записей-из-другой-таблицы)
- [Добавление записей, вложенные запросы](#добавление-записей-вложенные-запросы)
- [Запросы на обновление](#запросы-на-обновление)
- [Запросы на обновление нескольких столбцов](#запросы-на-обновление-нескольких-столбцов)
- [Запросы на обновление нескольких таблиц](#запросы-на-обновление-нескольких-таблиц)
- [Запросы на удаление](#запросы-на-удаление)
- [Запросы на создание таблицы](#запросы-на-создание-таблицы)
- [Оператор LIMIT](#оператор-limit)
- [Функция DATEDIFF](#функция-datediff)
- [Функция MONTH](#функция-month)
- [Функция MONTHNAME](#функция-monthname)
- [Использование временного имени таблицы (алиаса)](#использование-временного-имени-таблицы-алиаса)

### Добавление записей из другой таблицы

С помощью запроса на добавление можно не только добавить в таблицу конкретные значения (список `VALUES`), но и записи из другой таблицы, отобранные с помощью запроса на выборку. В этом случае вместо раздела `VALUES` записывается запрос на выборку, начинающийся с `SELECT`.  В нем можно использовать `WHERE`, `GROUP BY`, `ORDER BY`.

Правила соответствия между полями таблицы и вставляемыми значениями из запроса:

1. количество полей в таблице и количество полей в запросе должны совпадать;
2. должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый столбец запроса должен относиться к первому столбцу в списке столбцов таблицы, второй – ко второму столбцу и т.д.
3. типы столбцов запроса должны быть совместимы с типами данных соответствующих столбцов таблицы (целое число можно занести в поле типа `DECIMAL`, обратная операция – недопустима).

*Запрос*
```
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply;
```

### Добавление записей, вложенные запросы

В запросах на добавление можно использовать вложенные запросы.

*Запрос*
```
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply
WHERE title NOT IN (
        SELECT title 
        FROM book
      );
```

### Запросы на обновление

Под обновлением данных подразумевается изменение значений в существующих записях таблицы. При этом возможно как изменение значений полей в группе строк (даже всех строк таблицы), так и правка значения поля отдельной строки. Изменение записей в таблице реализуется с помощью запроса `UPDATE`. Простейший запрос на обновление выглядит так:

```
UPDATE таблица SET поле = выражение
```

где 
**таблица** – имя таблицы, в которой будут проводиться изменения;
**поле** – поле таблицы, в которое будет внесено изменение;
**выражение** – выражение, значение которого будет занесено в поле.

*Запрос*
```
UPDATE book 
SET price = 0.7 * price 
WHERE amount < 5;
```

### Запросы на обновление нескольких столбцов

Запросом `UPDATE` можно обновлять значения нескольких столбцов одновременно. В этом случае простейший запрос будет выглядеть так:

```
UPDATE таблица SET поле1 = выражение1, поле2 = выражение2
```

*Запрос*
```
UPDATE book 
SET amount = amount - buy,
    buy = 0;
```

### Запросы на обновление нескольких таблиц 

В запросах на обновление можно использовать несколько таблиц, но тогда

- для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся, например, `book.price` – столбец `price` из таблицы `book`, `supply.price` – столбец `price` из таблицы `supply`;
- все таблицы, используемые в запросе, нужно перечислить после ключевого слова `UPDATE`;
- в запросе обязательно условие `WHERE`, в котором указывается условие при котором обновляются данные.

*Запрос*
```
UPDATE book, supply 
SET book.amount = book.amount + supply.amount
WHERE book.title = supply.title AND book.author = supply.author;
```

### Запросы на удаление

Запросы корректировки данных позволяют удалить одну или несколько записей из таблицы. Простейший запрос на удаление имеет вид:

```
DELETE FROM таблица;
```

Этот запрос удаляет все записи из указанной после `FROM` таблицы.

*Запрос*
```
DELETE FROM supply 
WHERE title IN (
        SELECT title 
        FROM book
      );
```

### Запросы на создание таблицы

Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос `SELECT`, результирующая таблица которого и будет новой таблицей базы данных. При этом имена столбцов запроса становятся именами столбцов новой таблицы. Запрос на создание новой таблицы имеет вид:

```
CREATE TABLE имя_таблицы AS
SELECT ...
```

*Запрос*
```
CREATE TABLE ordering AS
SELECT author, title,
    (
        SELECT ROUND(AVG(amount)) 
        FROM book
    ) AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
```

### Оператор LIMIT

Для ограничения вывода записей в SQL используется оператор `LIMIT`, после которого указывается количество строк. Результирующая таблица будет иметь количество строк не более указанного после `LIMIT`. `LIMIT` размещается после раздела ORDER BY.

Как правило, этот оператор используется, чтобы отобрать заданное количество отсортированных строк результата запроса. 

*Запрос*
```
SELECT *
FROM trip
ORDER BY  date_first
LIMIT 1;
```

### Функция DATEDIFF

Для вычитания двух дат используется функция `DATEDIFF(дата_1, дата_2)`, результатом которой является количество дней между **дата_1** и **дата_2**. (По факту просто `дата_1 - дата_2`) Например,

```
DATEDIFF('2020-04-01', '2020-03-28') = 4
DATEDIFF('2020-05-09','2020-05-01') = 8
```

### Функция MONTH

Для того, чтобы выделить номер месяца из даты используется функция `MONTH(дата)`. Например,

```
MONTH('2020-04-12') = 4.
```

### Функция MONTHNAME

Для того, чтобы выделить название месяца из даты используется функция `MONTHNAME(дата)`, которая возвращает название месяца на английском языке для указанной даты. Например, 

```
MONTHNAME('2020-04-12') = 'April'
```

### Использование временного имени таблицы (алиаса)

Чтобы не писать название таблицы каждый раз, удобно использовать алиасы.

Алиас, это псевдоним, который мы присваивали столбцам после ключевого слова `AS`. Алиасы так же можно использовать и для таблиц. Это становится актуальным, при увеличении числа используемых таблиц, их иногда может быть и 5 и 10 и более. Псевдонимы помогают сделать запрос чище и читабельнее.

Для присваивания псевдонима существует 2 варианта: 

- с использованием ключевого слова `AS` 

```
FROM fine AS f, traffic_violation AS tv
```

- а так же и без него

```
FROM fine f, traffic_violation tv
```

После присвоения таблице алиаса, он используется во всех разделах запроса, в котором алиас задан. Например:

```
WHERE f.violation = tv.violation
```

*Запрос*
```
SELECT  f.name, f.number_plate, f.violation, 
   if(
    f.sum_fine = tv.sum_fine, "Стандартная сумма штрафа", 
    if(
      f.sum_fine < tv.sum_fine, "Уменьшенная сумма штрафа", "Увеличенная сумма штрафа"
    )
  ) AS description               
FROM  fine f, traffic_violation tv
WHERE tv.violation = f.violation and f.sum_fine IS NOT Null;
```
_________________



